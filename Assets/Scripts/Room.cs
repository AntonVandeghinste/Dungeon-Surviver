//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Room{

	static float roomSize;
	static float drawSpace;

	Vector3 position;
	List<Room> connectedRooms = new List<Room> ();
	List<Room> accessibleRooms = new List<Room> ();
	bool isAccesibleFromSpawn = false;
	Type type = Type.DEFAULT;
	bool deadEnd = false;

	public Room(){
	}

	public Room(Vector3 pos){

		position = pos;

	}

	public Room(Vector3 pos, Type type) {

		position = pos;
		this.type = type;

	}

	public static void setRoomSize(float size){

		roomSize = size;

	}

	public static void setDrawSpace(float space){

		drawSpace = space;

	}

	public void setType(Type type){

		this.type = type;

	}

	public void SetAccesibleFromSpawn () {
		
		if (!isAccesibleFromSpawn) {
			
			isAccesibleFromSpawn = true;
			foreach (Room accessibleRoom in accessibleRooms) {
				
				accessibleRoom.SetAccesibleFromSpawn();
				
			}
			
		}
		
	}

	public void SetDeadEnd(){

		deadEnd = true;

	}

	public bool IsDeadEnd() {

		return deadEnd;

	}

	public List<Room> AccessibleRooms(){

		return accessibleRooms;

	}

	public List<Room> ConnectedRooms(){

		return connectedRooms;

	}

	public bool IsAccessibleFromSpawn(){

		return isAccesibleFromSpawn;

	}

	public bool HasAccessTo(Room r){

		return accessibleRooms.Contains (r);

	}

	public void MakeAccessTo(Room room){

		accessibleRooms.Add (room);

	}

	public static void MakeAccessBetween(Room a, Room b){

		if (a.IsAccessibleFromSpawn ()) {

			b.SetAccesibleFromSpawn ();

		} else if (b.IsAccessibleFromSpawn ()) {

			a.SetAccesibleFromSpawn ();

		}

		a.MakeAccessTo (b);
		b.MakeAccessTo (a);

	}

	public void Connect(Room r) {

		connectedRooms.Add (r);

	}

	public void Disconnect(Room r) {

		connectedRooms.Remove (r);

	}

	public static void ConnectRooms(Room a, Room b){

		a.Connect (b);
		b.Connect (a);

	}

	public static void DisconnectRooms(Room a, Room b) {

		a.Disconnect (b);
		b.Disconnect (a);

	}

	public void DisconnectRooms() {

		List<Room> temp = connectedRooms;
		connectedRooms.Clear ();
		foreach (Room r in temp) {

			r.Disconnect(this);

		}

	}

	public Vector3 getPosition() {

		return position;

	}

	public Boolean TypeOf(Type t){

		return type == t;

	}

	public override string ToString ()
	{

		return "Room at position: " + position.ToString () + "\n" + type.ToString();

	}
	
}

public class Type
{

	public static readonly Type SPAWN = new Type ("Spawn");
	public static readonly Type DEFAULT = new Type ("Default");
	public static readonly Type ENEMY = new Type ("Enemy");
	public static readonly Type PUZZLE = new Type ("Puzzle");
	public static readonly Type DEBUG = new Type ("Debug");
	public static readonly Type EXIT = new Type ("Exit");
	public readonly Type BOSS;

	public static IEnumerable<Type> Values
	{

		get
		{

			yield return DEFAULT;
			yield return SPAWN;
			yield return ENEMY;
			yield return PUZZLE;
			yield return DEBUG;
			yield return EXIT;

		}

	}

	private readonly string name;
	private readonly Type super;

	Type(string name)
	{

		this.name = name;
		this.super = Type.DEFAULT;
		if (name == "Enemy") {

			this.BOSS = new Type("Boss", this);

		}

	}

	Type (string name, Type super){

		this.name = name;
		this.super = super;

	}

	public string Name { get { return name; } }

	public override string ToString ()
	{

		return "Type::" + name;

	}

}