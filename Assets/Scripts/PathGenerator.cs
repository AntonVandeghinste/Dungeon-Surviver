//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Collections.Generic;

public static class PathGenerator
{

	public static void GeneratePath(Room[,,] map, List<Room> rooms){

		Room spawn = new Room ();
		int N = 1, S = 2, E = 4, W = 8, U = 16, D = 32;

		foreach (Room room in rooms) {

			if(room.TypeOf(Type.SPAWN)){

				spawn = room;
				break;

			}

		}

		List<int> directions = new List<int> ();
		directions.Add (N);
		directions.Add (S);
		directions.Add (E);
		directions.Add (W);
		directions.Add (U);
		directions.Add (D);

		Dictionary<int, int> DX = new Dictionary<int, int> ();
		DX.Add (E, 1);
		DX.Add (W, -1);
		DX.Add (N, 0);
		DX.Add (S, 0);
		DX.Add (U, 0);
		DX.Add (D, 0);

		Dictionary<int, int> DY = new Dictionary<int, int> ();
		DY.Add (E, 0);
		DY.Add (W, 0);
		DY.Add (N, 0);
		DY.Add (S, 0);
		DY.Add (U, 1);
		DY.Add (D, -1);

		Dictionary<int, int> DZ = new Dictionary<int, int> ();
		DZ.Add (E, 0);
		DZ.Add (W, 0);
		DZ.Add (N, -1);
		DZ.Add (S, 1);
		DZ.Add (U, 0);
		DZ.Add (D, 0);

		Dictionary<int, int> OPPOSITE = new Dictionary<int, int> ();
		OPPOSITE.Add (E, W);
		OPPOSITE.Add (W, E);
		OPPOSITE.Add (N, S);
		OPPOSITE.Add (S, N);
		OPPOSITE.Add (U, D);
		OPPOSITE.Add (D, U);

		Room current = spawn;
		Room[] previous = new Room[rooms.Count];
		List<Room> processed = new List<Room> ();
		int i = 0;
		while (current != spawn || processed.Count < rooms.Count) {

			bool connected = false;
			directions.Shuffle ();
			if(!processed.Contains(current))
				processed.Add (current);
			//Debug.Log ("started");

			foreach(int direction in directions){

				if(!MapGenerator2.IsInMapRange ((int) current.getPosition ().x + DX[direction], (int) current.getPosition ().y + DY[direction], (int) current.getPosition ().z + DZ[direction]))
					continue;
				Room next = map[(int) current.getPosition ().x + DX[direction], (int) current.getPosition ().y + DY[direction], (int) current.getPosition ().z + DZ[direction]];
				//Debug.Log ("trying: " + next);

				if(next != null && !processed.Contains(next)){

					//Debug.Log ("Making connection between " + current + " and " + next);
					Room.ConnectRooms(current, next);
					previous[i] = current;
					current = next;
					i++;
					connected = true;
					break;

				}

			}

			if(!connected){

				//Debug.Log ("returning to previous room: " + previous);
				i--;
				i = i < 1 ? 0 : i;
				current = previous[i];

			}

		}

	}

	public static void Shuffle<T>(this IList<T> list){

		int n = list.Count;
		System.Random rand = new System.Random ();
		while (n > 1) {

			n--;
			int k = rand.Next (n + 1);
			T value = list[k];
			list[k] = list[n];
			list[n] = value;

		}

	}

}